/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	char *text;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */



%token tBREAK;
%token tCASE;
%token tCHAN;
%token tCONST;
%token tCONTINUE;

%token tDEFAULT;
%token tDEFER;
%token tELSE;
%token tFALLTHROUGH;
%token tFOR

%token tFUNC;
%token tGO;
%token tGOTO;
%token tIF;
%token tIMPORT;

%token tINTERFACE;
%token tMAP;
%token tPACKAGE;
%token tRANGE;
%token tRETURN;

%token tSELECT;
%token tSTRUCT;
%token tSWITCH;
%token tTYPE;
%token tVAR;

%token tPRINT;
%token tPRINTLN;
%token tAPPEND;

// Double character operators

%token tLSHIFT;
%token tRSHIFT;
%token tBWANDNOT;

%token tPLUSASSIGN;
%token tMINUSASSIGN;
%token tTIMESASSIGN;
%token tDIVASSIGN;
%token tREMASSIGN;

%token tBWANDASSIGN;
%token tBWORASSIGN;
%token tBWXORASSIGN;
%token tLSHIFTASSIGN;
%token tRSHIFTASSIGN;
%token tBWANDNOTASSIGN;

%token tAND;
%token tOR;
%token tARROW;
%token tINC;
%token tDEC;

%token tEQUAL;

%token tNE;
%token tLE;
%token tGE;
%token tDEFINE;
%token tELLIPSIS;

%token '+'
%token '-'
%token '*'
%token '/'
%token '%'
%token '&'
%token '|'
%token '^'
%token '<'
%token '>'
%token '='
%token '!'
%token '('
%token ')'
%token '['
%token ']'
%token '{'
%token '}'
%token ','
%token '.'
%token ';'
%token ':'


%token <text> tINTVAL
%token <text> tFLOATVAL
%token <text> tSTRINGVAL
%token <text> tRUNEVAL

%token <text> tIDENTIFIER

%token UNARY

/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */

%left tOR
%left tAND
%nonassoc tEQ tNEQ
%left '+' '-'
%left '*' '/'
%left UNARY

/* Start token (by default if this is missing it takes the first production */
%start program

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
%%

// FILE STRUCTURE
// =============================

program : PackageClause ';' TopLevelDecls
    ;

// PRIMARY PROGRAM STRUCTURE
// =============================


PackageClause : tPACKAGE tIDENTIFIER
    ;

TopLevelDecls : 
    | TopLevelDecl ';' TopLevelDecls
    ;


// DECLARATION STRUCTURE
// ============================

Declaration : TypeDecl
    | VarDecl
    ;

TopLevelDecl : Declaration 
    | FunctionDecl
    ;



// DECLARATIONS
// ============================

ShortVarDecl : tVAR IdentifierList tDEFINE ExpressionList
    ;

FunctionDecl : tFUNC tIDENTIFIER FuncSignature Block
    ;


// VARIABLE DECLARATION
// ===========================

// TODO WEED: check that the numbers on each side are the same

VarDecl : tVAR IdentifierList Type
    | tVAR '(' VarSpecs ')'
    | ShortVarDecl
    ;

VarSpecs :
    | VarSpec ';' VarSpecs
    ;

VarSpec : IdentifierList Type
    | IdentifierList Type '=' ExpressionList
    | IdentifierList '=' ExpressionList
    ;

IdentifierList : tIDENTIFIER
    | tIDENTIFIER ',' IdentifierList
    ;

ExpressionList : Expression
    | Expression ',' ExpressionList
    ;


// FUNCTION DECLARATION
// ============================

FuncSignature: FuncParameters FuncResult
    ;

FuncParameters: '('  FuncParameterList  ')'
    ;

FuncResult:
    | Type

FuncParameterList: FuncParameterDecl
    | FuncParameterDecl ',' FuncParameterDecl
    ;

FuncParameterDecl: IdentifierList
    | IdentifierList Type
    | tELLIPSIS Type
    ;


// TYPE STRUCTURE
// ============================

Type : TypeName
    | TypeLit
    | '(' Type ')'
    ;

TypeName : tIDENTIFIER
    ;

TypeLit : ArrayType
    | StructType
    /*| FunctionType*/
    | SliceType
    ;

// TYPE DECLARATIONS
// ============================
TypeDecl : tTYPE TypeSpec
    | tTYPE '(' TypeSpecs ')'
    ;

TypeSpecs : /*empty*/
    | TypeSpec ';' TypeSpecs
    ;

TypeSpec : AliasDecl
    | TypeDef
    ;

// We probably don't need this
AliasDecl : tIDENTIFIER '=' Type
    ;

TypeDef : tIDENTIFIER Type
    ;


// STRUCT TYPES
// ============================

StructType : tSTRUCT '{'  FieldDecls '}'
    ;

FieldDecls : /*empty*/
           | FieldDecl ';' FieldDecls

FieldDecl : IdentifierList Type
    ;


// OTHER TYPES
// ============================

ArrayType : '[' tINTVAL ']' Type
    ;

// TODO (or probably not)
FunctionType :
    ;

SliceType : '[' ']' Type
    ;


// STATEMENT STRUCTURE
// ============================

Statement : Declaration
    | SimpleStmt
    | ReturnStmt
    | BreakStmt
    | ContinueStmt
    | Block
    | IfStmt
    | SwitchStmt
    | ForStmt
    | PrintStmt
    | PrintlnStmt
    ;

SimpleStmt : EmptyStmt
    | ExpressionStmt
    | IncDecStmt
    | Assignment
    | ShortVarDecl
    ;


// STATEMENTS
// ============================

Block : '{' StatementList '}'
    ;

ExpressionStmt : Expression
    ;

Assignment: ExpressionList assign_op ExpressionList
    ;

IncDecStmt: Expression tINC
    | Expression tDEC
    ;

PrintStmt: tPRINT '(' ExpressionList ')'
    ;

PrintlnStmt: tPRINTLN '(' ExpressionList ')'
    ;

ReturnStmt: tRETURN ExpressionList
    ;

IfStmt: tIF SimpleStmt Expression Block ElseStmt
    ;

ElseStmt: IfStmt
    | Block
    ;

SwitchStmt: tSWITCH SimpleStmt Expression '{' CaseClause '}'
    ;

ForStmt: tFOR Block
    | tFOR Expression Block
    | tFOR ForClause Block
    ;

BreakStmt: tBREAK
    | tBREAK tIDENTIFIER
    ;

ContinueStmt: tCONTINUE
    | tCONTINUE tIDENTIFIER
    ;

EmptyStmt:
    ;


// STATEMENT SUBGROUPS
// ============================

StatementList: Statement
    | Statement ';' StatementList
    ;

assign_op:  add_op '='
    | mul_op '='
    ;

add_op: '+'
    | '-'
    | '|'
    | '^'
    ;

mul_op: '*'
    | '/'
    | '%'
    | tLSHIFT
    | tRSHIFT
    | '&'
    | tBWANDNOT
    ;

CaseClause: SwitchCase ':' StatementList
    ;

SwitchCase: tCASE ExpressionList
    | tCASE tDEFAULT
    ;

ForClause: SimpleStmt ';' Expression ';' SimpleStmt
    ;



// EXPRESSIONS
// ============================

Expression:
    ;


// EXPRESSION SUBGROUP
// ============================

ExpressionList: Expression
    | Expression ',' ExpressionList
    ;

%%

