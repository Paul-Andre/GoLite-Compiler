/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	char *text;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */



%token tBREAK;
%token tCASE;
%token tCHAN;
%token tCONST;
%token tCONTINUE;

%token tDEFAULT;
%token tDEFER;
%token tELSE;
%token tFALLTHROUGH;
%token tFOR

%token tFUNC;
%token tGO;
%token tGOTO;
%token tIF;
%token tIMPORT;

%token tINTERFACE;
%token tMAP;
%token tPACKAGE;
%token tRANGE;
%token tRETURN;

%token tSELECT;
%token tSTRUCT;
%token tSWITCH;
%token tTYPE;
%token tVAR;

%token tPRINT;
%token tPRINTLN;
%token tAPPEND;

// Double character operators

%token tLSHIFT;
%token tRSHIFT;
%token tBWANDNOT;

%token tPLUSASSIGN;
%token tMINUSASSIGN;
%token tTIMESASSIGN;
%token tDIVASSIGN;
%token tREMASSIGN;

%token tBWANDASSIGN;
%token tBWORASSIGN;
%token tBWXORASSIGN;
%token tLSHIFTASSIGN;
%token tRSHIFTASSIGN;
%token tBWANDNOTASSIGN;

%token tAND;
%token tOR;
%token tARROW;
%token tINC;
%token tDEC;

%token tEQUAL;

%token tNE;
%token tLE;
%token tGE;
%token tDEFINE;
%token tELLIPSIS;

%token '+'
%token '-'
%token '*'
%token '/'
%token '%'
%token '&'
%token '|'
%token '^'
%token '<'
%token '>'
%token '='
%token '!'
%token '('
%token ')'
%token '['
%token ']'
%token '{'
%token '}'
%token ','
%token '.'
%token ';'
%token ':'


%token <text> tINTVAL
%token <text> tFLOATVAL
%token <text> tSTRINGVAL
%token <text> tRUNEVAL

%token <text> tIDENTIFIER

%token UNARY

/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */

%left tOR
%left tAND
%nonassoc tEQ tNEQ
%left '+' '-'
%left '*' '/'
%left UNARY

/* Start token (by default if this is missing it takes the first production */
%start program

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
%%

// FILE STRUCTURE
// =============================

program : PackageClause ';' TopLevelDecls
    ;

// PRIMARY PROGRAM STRUCTURE
// =============================


PackageClause : tPACKAGE tIDENTIFIER
    ;

TopLevelDecls : 
    | TopLevelDecl ';' TopLevelDecls
    ;


// DECLARATION STRUCTURE
// ============================

TopLevelDecl : Declaration 
    | FunctionDecl
    ;

Declaration : VarDecl
    | TypeDecl
    ;


// DECLARATIONS
// ============================


VarDecl : tVAR IdentifierList Type
    | tVAR '(' VarSpecs ')'
    | ShortVarDecl
    ;

ShortVarDecl : tVAR IdentifierList tDEFINE ExpressionList
    ;

FunctionDecl : tFUNC tIDENTIFIER FuncSignature Block
    ;


// FUNCTION DECLARATION HELPERS
// ============================

FuncSignature: FuncParameters FuncResult
    ;

FuncParameters: "("  FuncParameterList  ")"
    ;

FuncResult:
    | Type

FuncParameterList: FuncParameterDecl
    | FuncParameterDecl "," FuncParameterDecl
    ;

FuncParameterDecl: IdentifierList
    | IdentifierList Type
    | tELLIPSIS Type



// TYPE STRUCTURE
// ============================

Type : TypeName
    | TypeLit
    | '(' Type ')'
    ;

// TODO: DO WE NEED QUALIFIED IDENTIFIER ..?

TypeName : tIDENTIFIER
    | QualifiedIdent
    ;

TypeLit : BasicType
    | ArrayType
    | StructType
    | FunctionType
    | SliceType
    ;


// TYPES
// ============================

BasicType: 



Block : "{" StatementList "}"
    ;

StatementList = Statement ";"






VarSpecs :
    | VarSpec ';' VarSpecs
    ;

VarSpec : IdentifierList Type 
    | IdentifierList Type '=' ExpressionList
    | IdentifierList '=' ExpressionList
    ;

IdentifierList : tIDENTIFIER
    | tIDENTIFIER ',' IdentifierList
    ;

ExpressionList : Expression
    | Expression ',' ExpressionList
    ;





QualifiedIdent :
    ;

ArrayType :
    ;

StructType :
    ;

FunctionType :
    ;

SliceType :
    ;

TypeDecl :
    ;


Expression : 
    ;

%%

