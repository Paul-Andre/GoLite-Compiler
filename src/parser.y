/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>
#include "ast.h"

// Reference to the line number generated by the scanner
extern int yylineno;
extern root;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
    char *text;
    ExpressionNode *expr;
    ExpressionNodeVec *expr_vec;
    StringVec *string_vec;
    StatementNode *stmt;
    StatementNodeVec *stmt_vec;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */



%token tBREAK;
%token tCASE;
%token tCHAN;
%token tCONST;
%token tCONTINUE;

%token tDEFAULT;
%token tDEFER;
%token tELSE;
%token tFALLTHROUGH;
%token tFOR

%token tFUNC;
%token tGO;
%token tGOTO;
%token tIF;
%token tIMPORT;

%token tINTERFACE;
%token tMAP;
%token tPACKAGE;
%token tRANGE;
%token tRETURN;

%token tSELECT;
%token tSTRUCT;
%token tSWITCH;
%token tTYPE;
%token tVAR;

%token tPRINT;
%token tPRINTLN;
%token tAPPEND;

// Double character operators

%token tLSHIFT;
%token tRSHIFT;
%token tBWANDNOT;

%token tPLUSASSIGN;
%token tMINUSASSIGN;
%token tTIMESASSIGN;
%token tDIVASSIGN;
%token tREMASSIGN;

%token tBWANDASSIGN;
%token tBWORASSIGN;
%token tBWXORASSIGN;
%token tLSHIFTASSIGN;
%token tRSHIFTASSIGN;
%token tBWANDNOTASSIGN;

%token tAND;
%token tOR;
%token tARROW;
%token tINC;
%token tDEC;

%token tEQUAL;

%token tNE;
%token tLE;
%token tGE;
%token tDEFINE;
%token tELLIPSIS;

%token '+'
%token '-'
%token '*'
%token '/'
%token '%'
%token '&'
%token '|'
%token '^'
%token '<'
%token '>'
%token '='
%token '!'
%token '('
%token ')'
%token '['
%token ']'
%token '{'
%token '}'
%token ','
%token '.'
%token ';'
%token ':'


%token <text> tINTVAL
%token <text> tFLOATVAL
%token <text> tRUNEVAL
%token <text> tSTRINGVAL

%token <text> tIDENTIFIER

%type <expr> Operand
%type <expr> Expression
%type <expr> UnaryExpr
%type <expr> AppendExpr
%type <expr> PrimaryExpr
%type <expr> Literal

%type <expr_vec> expression_list
%type <expr_vec> OptionalExpressionList

%type <stmt> ExpressionStmt
%type <stmt> Assignment
%type <stmt> Declaration
%type <stmt> SimpleStmt
%type <stmt> BreakStmt
%type <stmt> ContinueStmt
%type <stmt> IfStmt
%type <stmt> SwitchStmt
%type <stmt> ForStmt
%type <stmt> PrintStmt
%type <stmt> PrintlnStmt

%type <stmt_vec> StatementList
%type <stmt_vec> Block



%token UNARY_PREC
%token REL_PREC
%token ADD_PREC
%token MUL_PREC

%left tOR
%left tAND
%left tEQUAL tNE '<' tLE '>' tGE REL_PREC
%left '+' '-' '|' '^' ADD_PREC
%left '*' '/' '%' tLSHIFT tRSHIFT '&' tBWANDNOT MUL_PREC

%left UNARY_PREC '!'


/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */

/*
%left tOR
%left tAND
%left rel_op
%left add_op
%left mul_op

%left unary_op
*/


/* Start token (by default if this is missing it takes the first production */
%start program

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */

%glr-parser
%expect-rr 1

%%

// FILE STRUCTURE
// =============================

program : PackageClause ';' TopLevelDecls { root = $1 }
    ;

// PRIMARY PROGRAM STRUCTURE
// =============================


PackageClause : tPACKAGE tIDENTIFIER { }
    ;

TopLevelDecls : %empty                  { }
    | TopLevelDecl ';' TopLevelDecls
    ;


// DECLARATION STRUCTURE
// ============================

Declaration : TypeDecl      { $$ = make_declaration_statement() }
    | VarDecl               { $$ = make_declaration_statement() }
    ;

TopLevelDecl : Declaration 
    | FunctionDecl
    ;




// VARIABLE DECLARATION
// ===========================

// TODO WEED: check that the numbers on each side are the same

VarDecl : tVAR VarSpec          
    | tVAR '(' VarSpecs ')'
    ;

VarSpecs : %empty
    | VarSpecs VarSpec ';'
    ;

VarSpec : identifier_list Type
    | identifier_list Type '=' expression_list
    | identifier_list '=' expression_list
    ;

identifier_list : tIDENTIFIER
    | identifier_list ',' tIDENTIFIER
    ;

expression_list : Expression
               {
               $$ = make_expr_vec();
               expr_vec_push($$, $1);
               }
    | expression_list ',' Expression
               {
               $$ = $1;
               expr_vec_push($$, $3);
               }
    ;


// TYPE DECLARATIONS
// ============================
TypeDecl : tTYPE TypeSpec
    | tTYPE '(' TypeSpecs ')'
    ;

TypeSpecs : %empty
    | TypeSpecs TypeSpec ';'
    ;

TypeSpec : AliasDecl
    | TypeDef
    ;

// We probably don't need this
AliasDecl : tIDENTIFIER '=' Type
    ;

TypeDef : tIDENTIFIER Type
    ;



// FUNCTION DECLARATION
// ============================

FunctionDecl : tFUNC tIDENTIFIER FuncSignature Block    
    ;

FuncSignature: FuncParameters FuncResult
    ;

FuncParameters: '('  OptionalFuncParameterList  ')'
    ;

FuncResult: %empty
    | Type
    ;

FuncParameterList: FuncParameterDecl
    | FuncParameterList ',' FuncParameterDecl
    ;

OptionalFuncParameterList: %empty
    | FuncParameterList
    ;

FuncParameterDecl: identifier_list Type
    ;



// TYPES
// ============================

Type : TypeName
    | TypeLit
    | '(' Type ')'
    ;

// Basic types are just identifiers
TypeName : tIDENTIFIER
    ;

TypeLit : ArrayType
    | StructType
    | SliceType
    ;


// SLICES

SliceType : '[' ']' Type
    ;


// ARRAYS

ArrayType : '[' tINTVAL ']' Type
    ;


// STRUCTS

StructType : tSTRUCT '{'  FieldDecls '}'
    ;

FieldDecls : %empty
           | FieldDecls FieldDecl ';'

FieldDecl : identifier_list Type
    ;



// STATEMENT STRUCTURE
// ============================

// Need to double check if we support fallthrough 
Statement : Declaration
    | SimpleStmt
    | ReturnStmt
    | BreakStmt
    | ContinueStmt
    | Block                 { $$ = make_block_statement(yylineno, $1) }
    | IfStmt
    | SwitchStmt
    | ForStmt
    | PrintStmt
    | PrintlnStmt
    ;

SimpleStmt : EmptyStmt
    | ExpressionStmt
    | IncDecStmt
    | Assignment
    | ShortVarDecl
    ;


// STATEMENTS
// ============================


EmptyStmt: %empty               { $$ = make_empty_statement(yylineno); }
    ;

Block : '{' StatementList '}'   
    ;

StatementList: %empty                       { $$ = make_stmt_vec() }
             | StatementList Statement ';'  
             { 
                $$ = $1;
                $$ = stmt_vec_push($$, $2);
             }
             ;

// TODO WEED: not all expressions are valid; need to weed
ExpressionStmt : Expression { $$ = make_expression_statement(yylineno, $1); }
    ;


// TODO WEED: make sure number is same on both sides
// TODO: perhaps split this into to seperate rules, one for "=" and one for the rest
Assignment: expression_list '=' expression_list   
                { $$ = make_assignment_statement(yylineno, $1, $3) }
            expression add_assign_op expression
                { $$ = make_op_assignment_statement(yylineno, $1, $3, $2) }
            expression mul_assign_op expression
                { $$ = make_op_assignment_statement(yylineno, $1, $3, $2) }
    ;


add_assign_op : tPLUSASSIGN       { $$ = opAdd }
              | tMINUSASSIGN      { $$ = opSub }
              | tBWORASSIGN       { $$ = opBwOr }
              | tBWXORASSIGN      { $$ = opBwXor }
              ;

mul_assign_op : tTIMESASSIGN      { $$ = opMul }
              | tDIVASSIGN        { $$ = opDiv }
              | tREMASSIGN        { $$ = opMod }
              | tLSHIFTASSIGN     { $$ = opLShift }
              | tRSHIFTASSIGN     { $$ = opRShift }
              | tBWANDASSIGN      { $$ = opBwAnd }
              | tBWANDNOTASSIGN   { $$ = opBwAndNot }
              ;


// declaration statements are just Declarations; they were done earlier

// TODO WEED: same number on both sides. Also check for the correct use of _
ShortVarDecl : identifier_list tDEFINE expression_list
             { $$ = make_short_var_declaration_statement(yylineno, $1, $3) }
    ;

IncDecStmt: Expression tINC { $$ = make_inc_dec_statement(yylineno, 0, $1) }
    | Expression tDEC       { $$ = make_inc_dec_statement(yylineno, 1, $1) }
    ;

PrintStmt: tPRINT '(' OptionalExpressionList ')' { $$ = make_print_statement(yylineno, $3) }
    ;

PrintlnStmt: tPRINTLN '(' OptionalExpressionList ')' { $$ = make_println_statement(yylineno, $3) }
    ;

ReturnStmt: tRETURN             
          | tRETURN Expression
          ;


IfStmt: tIF SimpleStmt ';' Expression Block ElseStmt 
            { $$ = make_if_statement(yylineno, $2, $4, $5, $6) }
      | tIF Expression Block ElseStmt
            { $$ = make_if_statement(yylineno, NULL, $2, $3, $4) }
      ;

ElseStmt: %empty        { $$ = NULL }
        | tELSE IfStmt
        | tELSE Block   { $$ = make_block_statement(yylineno, $2) }
        ;


SwitchStmt: tSWITCH SimpleStmt ';' Expression '{' CaseClauses '}'
                { $$ = make_switch_statement(yylineno, $2, $4, $6) }
          | tSWITCH Expression '{' CaseClauses '}'
                { $$ = make_switch_statement(yylineno, NULL, $2, $4) }
          | tSWITCH SimpleStmt ';' '{' CaseClauses '}'
                { $$ = make_switch_statement(yylineno, $2, NULL, $5) }
          | tSWITCH '{' CaseClauses '}'
                { $$ = make_switch_statement(yylineno, NULL, NULL, $6) }
    ;

CaseClauses: %empty                 { $$ = make_case_clause_vec() }
           | CaseClauses CaseClause 
                { 
                $$ = $1;
                case_clause_vec_push($$, $2);
                }
           ;

// TODO: decide if maybe to fuse to next two rules for easier AST building
CaseClause: SwitchCase ':' StatementList    { $$ = make_case_clause(yylineno, $1, $3) }
    ;

SwitchCase: tCASE expression_list           
    | tDEFAULT
    ;


ForStmt: tFOR Block                         { $$ = make_loop_statement(yylineno, $2) }
    | tFOR Expression Block                 { $$ = make_while_statement(yylineno, $2, $3) }
    | tFOR SimpleStmt ';' Expression ';' SimpleStmt Block
        { $$ = make_for_statement(yylineno, $2, $4, $6, $7); }
    ;

// TODO WEED: make sure the last SimpleStmt is not a short variable declaration
// SimpleStmt can be empty, so not explicitly making them optional should be fine

BreakStmt: tBREAK           { $$ = make_break_statement(yylineno) }
    ;

ContinueStmt: tCONTINUE     { $$ = make_continue_statement(yylineno) }
    ;





// EXPRESSIONS
// ============================

Expression: UnaryExpr                                    
          | Expression tOR Expression                    
            {$$ = make_bin_operation_expression(yylieno, $2, opOr, $2)}
          | Expression tAND Expression                   
            {$$ = make_bin_operation_expression(yylineno, $2, opAnd, $2)}
          | Expression rel_op Expression %prec REL_PREC  
            {$$ = make_bin_operation_expression(yylineno, $2, $1, $2)}
          | Expression add_op Expression %prec ADD_PREC  
            {$$ = make_bin_operation_expression(yylineno, $2, $1, $2)}
          | Expression mul_op Expression %prec MUL_PREC  
            {$$ = make_bin_operation_expression(yylineno, $2, $1, $2)}
          ;

UnaryExpr: PrimaryExpr                                  
         | unary_op UnaryExpr %prec UNARY_PREC 
            { $$ = make_unary_operation_expression(yylieno, $1, $2) }
         ;

rel_op: tEQUAL              { $$ = opEq }
      | tNE                 { $$ = opNeq }
      | '<'                 { $$ = opLt }
      | tLE                 { $$ = opLeq }
      | '>'                 { $$ = opGt }
      | tGE                 { $$ = opGeq }
      ;

add_op: '+'                 { $$ = opAdd }
    | '-'                   { $$ = opSub }
    | '|'                   { $$ = opBwOr }
    | '^'                   { $$ = opBwXor }
    ;

mul_op: '*'                 { $$ = opMul }
    | '/'                   { $$ = opDiv }
    | '%'                   { $$ = opMod }
    | tLSHIFT               { $$ = opLShift }
    | tRSHIFT               { $$ = opRShift }
    | '&'                   { $$ = opBwAnd }
    | tBWANDNOT             { $$ = opBwAndNot }
    ;

unary_op: '+'               { $$ = opPlus }
        | '-'               { $$ = opNeg }
        | '!'               { $$ = opBwCompl }
        | '^'               { $$ = opNot }
        ;

Operand: Literal
       | tIDENTIFIER        { $$ = expr_identifier(yylineno, $1); }
       | '(' Expression ')'
       ;

Literal: tINTVAL            {$$ = expr_literal(yylineno, $1, kInt);}
       | tFLOATVAL          {$$ = expr_literal(yylineno, $1, kFloat);}
       | tRUNEVAL           {$$ = expr_literal(yylineno, $1, kRune);}
       | tSTRINGVAL         {$$ = expr_literal(yylineno, $1, kString);}
       ;

PrimaryExpr: Operand
           | PrimaryExpr Selector   { $$ = make_selector_expression(yylineno, $1, $2) }
           | PrimaryExpr Index      { $$ = make_index_expression(yylineno, $1, $2) }
           | AppendExpr             { $$ = $1 }
           | PrimaryExpr Arguments  { $$ = make_function_call_expression(yylineno, $1, $2) }
           ;

// TODO WEED: must not be blank
Selector: '.' tIDENTIFIER
        ;

Index: '[' Expression ']'
     ;

Arguments: '(' OptionalExpressionList ')'
         ;

AppendExpr: tAPPEND '(' Expression ',' Expression ')' 
          { $$ = make_append_expression(yylineno, $3, $5); }
          ;


// Type casts are syntactically function calls


// EXPRESSION SUBGROUP
// ============================


OptionalExpressionList: %empty          { $$ = make_expr_vec(); }
                      | expression_list
                      ;

%%

