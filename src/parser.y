/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>
#include "ast.h"

// Reference to the line number generated by the scanner
extern int yylineno;

Program *root;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
    char *text;
    AstKindNode *ast_kind;
    ExpressionNode *expr;
    ExpressionNodeVec *expression_vec;
    StringVec *string_vec;
    StatementNode *stmt;
    StatementNodeVec *stmt_vec;
    enum BinaryOperator bin_op;
    enum UnaryOperator un_op;
    CaseClause *case_clause;
    CaseClauseVec *case_clause_vec; 
    TopLevelDeclarationNode *top_level_decl;
    TopLevelDeclarationNodeVec *top_level_decl_vec;
    VarSpec *var_spec;
    VarSpecVec *var_spec_vec;    
    TypeSpec *type_spec;
    TypeSpecVec *type_spec_vec;    
    Program *program;
    Field *field;
    FieldVec *field_vec;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */



%token tBREAK;
%token tCASE;
%token tCHAN;
%token tCONST;
%token tCONTINUE;

%token tDEFAULT;
%token tDEFER;
%token tELSE;
%token tFALLTHROUGH;
%token tFOR

%token tFUNC;
%token tGO;
%token tGOTO;
%token tIF;
%token tIMPORT;

%token tINTERFACE;
%token tMAP;
%token tPACKAGE;
%token tRANGE;
%token tRETURN;

%token tSELECT;
%token tSTRUCT;
%token tSWITCH;
%token tTYPE;
%token tVAR;

%token tPRINT;
%token tPRINTLN;
%token tAPPEND;

// Double character operators

%token tLSHIFT;
%token tRSHIFT;
%token tBWANDNOT;

%token tPLUSASSIGN;
%token tMINUSASSIGN;
%token tTIMESASSIGN;
%token tDIVASSIGN;
%token tREMASSIGN;

%token tBWANDASSIGN;
%token tBWORASSIGN;
%token tBWXORASSIGN;
%token tLSHIFTASSIGN;
%token tRSHIFTASSIGN;
%token tBWANDNOTASSIGN;

%token tAND;
%token tOR;
%token tARROW;
%token tINC;
%token tDEC;

%token tEQUAL;

%token tNE;
%token tLE;
%token tGE;
%token tDEFINE;
%token tELLIPSIS;

%token '+'
%token '-'
%token '*'
%token '/'
%token '%'
%token '&'
%token '|'
%token '^'
%token '<'
%token '>'
%token '='
%token '!'
%token '('
%token ')'
%token '['
%token ']'
%token '{'
%token '}'
%token ','
%token '.'
%token ';'
%token ':'


%token <text> tINTVAL
%token <text> tFLOATVAL
%token <text> tRUNEVAL
%token <text> tSTRINGVAL
%token <text> tIDENTIFIER

%type <text> Selector

// Operators
%type <bin_op> add_assign_op
%type <bin_op> mul_assign_op
%type <bin_op> rel_op
%type <bin_op> mul_op
%type <bin_op> add_op
%type <un_op> unary_op

// Declarations
%type <var_spec> VarSpec
%type <var_spec_vec> VarSpecs
%type <var_spec_vec> VarDecl

%type <string_vec> identifier_list

%type <type_spec> TypeSpec
%type <type_spec_vec> TypeSpecs
%type <type_spec_vec> TypeDecl

%type <ast_kind> Type
%type <ast_kind> TypeLit
%type <ast_kind> TypeName
%type <ast_kind> SliceType
%type <ast_kind> ArrayType
%type <ast_kind> StructType

%type <field_vec> FieldDecls
%type <field> FieldDecl
// Expressions
%type <expr> Operand
%type <expr> Expression
%type <expr> UnaryExpr
%type <expr> AppendExpr
%type <expr> PrimaryExpr
%type <expr> Literal

%type <expr> Index

%type <expression_vec> expression_list
%type <expression_vec> OptionalExpressionList
%type <expression_vec> Arguments

// Statements
%type <stmt> Statement

%type <stmt> SimpleStmt
%type <stmt> ReturnStmt
%type <stmt> BreakStmt
%type <stmt> ContinueStmt
%type <stmt> IfStmt
%type <stmt> SwitchStmt
%type <stmt> ForStmt
%type <stmt> PrintStmt
%type <stmt> PrintlnStmt

%type <stmt> ElseStmt

%type <stmt> EmptyStmt
%type <stmt> ExpressionStmt
%type <stmt> IncDecStmt
%type <stmt> Assignment
%type <stmt> ShortVarDecl

%type <stmt_vec> StatementList
%type <stmt_vec> Block

// Case Clause
%type <case_clause> CaseClause
%type <case_clause_vec> CaseClauses

%type <program> Program
%type <text> PackageClause
%type <top_level_decl> TopLevelDecl
%type <top_level_decl_vec> TopLevelDecls

// Function Declarations
%type <top_level_decl> FunctionDecl
%type <ast_kind> FuncResult
%type <field_vec> FuncParameterList
%type <field_vec> FuncParameters
%type <field_vec> OptionalFuncParameterList
%type <field> FuncParameterDecl


%token UNARY_PREC
%token REL_PREC
%token ADD_PREC
%token MUL_PREC

%left tOR
%left tAND
%left tEQUAL tNE '<' tLE '>' tGE REL_PREC
%left '+' '-' '|' '^' ADD_PREC
%left '*' '/' '%' tLSHIFT tRSHIFT '&' tBWANDNOT MUL_PREC

%left UNARY_PREC '!'


/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */

/*
%left tOR
%left tAND
%left rel_op
%left add_op
%left mul_op

%left unary_op
*/


/* Start token (by default if this is missing it takes the first production */
%start Program

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */

%glr-parser
%expect-rr 1

%%

// FILE STRUCTURE
// =============================

Program : PackageClause ';' TopLevelDecls { $$ = make_program($1, $3); root = $$; }
    ;

// PRIMARY PROGRAM STRUCTURE
// =============================


PackageClause : tPACKAGE tIDENTIFIER { $$ = $2; }
    ;

TopLevelDecls : %empty                  { $$ = make_top_level_declaration_vec(); }
    | TopLevelDecls TopLevelDecl ';' 
        {
        $$ = $1;
        top_level_declaration_vec_push($$, $2);
        }
    ;


// DECLARATION STRUCTURE
// ============================

TopLevelDecl : TypeDecl     { $$ = make_type_top_level_declaration(yylineno, $1); }
    | VarDecl               { $$ = make_var_top_level_declaration(yylineno, $1); }
    | FunctionDecl          { }
    ;




// VARIABLE DECLARATION
// ===========================

VarDecl : tVAR VarSpec         
        { 
        $$ = make_var_spec_vec();
        var_spec_vec_push($$, $2);
        }
    | tVAR '(' VarSpecs ')'
        { $$ = $3; }
    ;

VarSpecs : %empty
        { $$ = make_var_spec_vec(); }
    | VarSpecs VarSpec ';'
        {
        $$ = $1;
        var_spec_vec_push($$, $2);
        }
    ;

VarSpec : identifier_list Type      { $$ = make_var_spec(yylineno, $1, $2, NULL); }
    | identifier_list Type '=' expression_list { $$ = make_var_spec(yylineno, $1, $2, $4); }
    | identifier_list '=' expression_list      { $$ = make_var_spec(yylineno, $1, NULL, $3); }
    ;

identifier_list : tIDENTIFIER
                { 
                $$ = make_string_vec();
                string_vec_push($$, make_string($1));
                }
    | identifier_list ',' tIDENTIFIER
                {
                $$ = $1;
                string_vec_push($$, make_string($3));
                }
    ;

expression_list : Expression
               {
               $$ = make_expression_vec();
               expression_vec_push($$, $1);
               }
    | expression_list ',' Expression
               {
               $$ = $1;
               expression_vec_push($$, $3);
               }
    ;


// TYPE DECLARATIONS
// ============================
TypeDecl : tTYPE TypeSpec
        { 
        $$ = make_type_spec_vec();
        type_spec_vec_push($$, $2);
        }
    | tTYPE '(' TypeSpecs ')'
        { $$ = $3; }
    ;

TypeSpecs : %empty
        { $$ = make_type_spec_vec(); }
    | TypeSpecs TypeSpec ';'
        {
        $$ = $1;
        type_spec_vec_push($$, $2);
        }
    ;

TypeSpec : tIDENTIFIER Type  { $$ = make_type_spec(yylineno, $1, $2); }
    ;



// FUNCTION DECLARATION
// ============================

FunctionDecl : tFUNC tIDENTIFIER FuncParameters FuncResult Block    
             { $$ = make_function_top_level_declaration(yylineno, $2, $3, $4, $5); }
    ;

FuncParameters: '('  OptionalFuncParameterList  ')' { $$ = $2; }
    ;

FuncResult: %empty  { $$ = NULL; }
    | Type
    ;

FuncParameterList: FuncParameterDecl            
                 { 
                 $$ = make_field_vec();
                 field_vec_push($$, $1);
                 }
    | FuncParameterList ',' FuncParameterDecl
                 { 
                 $$ = $1;
                 field_vec_push($$, $3);
                 }
    ;

OptionalFuncParameterList: %empty { $$ = make_field_vec();}
    | FuncParameterList
    ;

FuncParameterDecl: identifier_list Type { $$ = make_field(yylineno, $1, $2); }
    ;



// TYPES
// ============================

Type : TypeName
    | TypeLit
    | '(' Type ')'  { $$ = $2; }
    ;

// Basic types are just identifiers
TypeName : tIDENTIFIER                      { $$ = make_identifier_kind(yylineno, $1); }
    ;

TypeLit : ArrayType
    | StructType
    | SliceType
    ;


// SLICES

SliceType : '[' ']' Type                    { $$ = make_slice_kind(yylineno, $3); }
    ;


// ARRAYS

ArrayType : '[' tINTVAL ']' Type            { $$ = make_array_kind(yylineno, $4, $2); }
    ;


// STRUCTS

StructType : tSTRUCT '{'  FieldDecls '}'    { $$ = make_struct_kind(yylineno, $3); }
    ;

FieldDecls : %empty                         { $$ = make_field_vec(); }
           | FieldDecls FieldDecl ';'      
                {
                $$ = $1;
                field_vec_push($$, $2);
                }
    ;

FieldDecl : identifier_list Type            { $$ = make_field(yylineno, $1, $2); }
    ;



// STATEMENT STRUCTURE
// ============================

// Need to double check if we support fallthrough 
Statement : VarDecl                         { $$ = make_var_declaration_statement(yylineno, $1); }
    | TypeDecl                              { $$ = make_type_declaration_statement(yylineno, $1); }
    | SimpleStmt
    | ReturnStmt
    | BreakStmt
    | ContinueStmt
    | Block                                 { $$ = make_block_statement(yylineno, $1); }
    | IfStmt
    | SwitchStmt
    | ForStmt
    | PrintStmt
    | PrintlnStmt
    ;

SimpleStmt : EmptyStmt
    | ExpressionStmt
    | IncDecStmt
    | Assignment
    | ShortVarDecl
    ;


// STATEMENTS
// ============================


EmptyStmt: %empty               { $$ = make_empty_statement(yylineno); }
    ;

Block : '{' StatementList '}'   { $$ = $2; }
    ;

StatementList: %empty                       { $$ = make_statement_vec(); }
             | StatementList Statement ';'  
             { 
                $$ = $1;
                statement_vec_push($$, $2);
             }
             ;

ExpressionStmt : Expression { $$ = make_expression_statement(yylineno, $1); }
    ;


Assignment: expression_list '=' expression_list
                { $$ = make_assignment_statement(yylineno, $1, $3); }
          | Expression add_assign_op Expression
                { $$ = make_op_assignment_statement(yylineno, $1, $3, $2); }
          | Expression mul_assign_op Expression
                { $$ = make_op_assignment_statement(yylineno, $1, $3, $2); }
    ;


add_assign_op : tPLUSASSIGN       { $$ = opAdd; }
              | tMINUSASSIGN      { $$ = opSub; }
              | tBWORASSIGN       { $$ = opBwOr; }
              | tBWXORASSIGN      { $$ = opBwXor; }
              ;

mul_assign_op : tTIMESASSIGN      { $$ = opMul; }
              | tDIVASSIGN        { $$ = opDiv; }
              | tREMASSIGN        { $$ = opMod; }
              | tLSHIFTASSIGN     { $$ = opLShift; }
              | tRSHIFTASSIGN     { $$ = opRShift; }
              | tBWANDASSIGN      { $$ = opBwAnd; }
              | tBWANDNOTASSIGN   { $$ = opBwAndNot; }
              ;


// declaration statements are just Declarations; they were done earlier

ShortVarDecl : identifier_list tDEFINE expression_list
             { $$ = make_short_var_declaration_statement(yylineno, $1, $3); }
    ;

IncDecStmt: Expression tINC { $$ = make_inc_dec_statement(yylineno, 0, $1); }
    | Expression tDEC       { $$ = make_inc_dec_statement(yylineno, 1, $1); }
    ;

PrintStmt: tPRINT '(' OptionalExpressionList ')' { $$ = make_print_statement(yylineno, $3); }
    ;

PrintlnStmt: tPRINTLN '(' OptionalExpressionList ')' { $$ = make_println_statement(yylineno, $3); }
    ;

ReturnStmt: tRETURN             { $$ = make_return_statement(yylineno, NULL); }
          | tRETURN Expression  { $$ = make_return_statement(yylineno, $2); }
          ;


IfStmt: tIF SimpleStmt ';' Expression Block ElseStmt 
            { $$ = make_if_statement(yylineno, $2, $4, $5, $6); }
      | tIF Expression Block ElseStmt
            { $$ = make_if_statement(yylineno, make_empty_statement(yylineno), $2, $3, $4); }
      ;

ElseStmt: %empty        { $$ = NULL; }
        | tELSE IfStmt  { $$ = $2; }
        | tELSE Block   { $$ = make_block_statement(yylineno, $2); }
        ;


SwitchStmt: tSWITCH SimpleStmt ';' Expression '{' CaseClauses '}'
                { $$ = make_switch_statement(yylineno, $2, $4, $6); }
          | tSWITCH Expression '{' CaseClauses '}'
                { $$ = make_switch_statement(yylineno, make_empty_statement(yylineno), $2, $4); }
          | tSWITCH SimpleStmt ';' '{' CaseClauses '}'
                { $$ = make_switch_statement(yylineno, $2, NULL, $5); }
          | tSWITCH '{' CaseClauses '}'
                { $$ = make_switch_statement(yylineno, make_empty_statement(yylineno), NULL, $3); }
    ;

CaseClauses: %empty                 { $$ = make_case_clause_vec(); }
           | CaseClauses CaseClause 
                { 
                $$ = $1;
                case_clause_vec_push($$, $2);
                }
           ;

CaseClause: tCASE expression_list ':' StatementList    { $$ = make_case_clause(yylineno, $2, $4); }
          | tDEFAULT ':' StatementList    { $$ = make_case_clause(yylineno, NULL, $3); }
    ;


ForStmt: tFOR Block                         { $$ = make_loop_statement(yylineno, $2); }
    | tFOR Expression Block                 { $$ = make_while_statement(yylineno, $2, $3); }
    | tFOR SimpleStmt ';' Expression ';' SimpleStmt Block
        { $$ = make_for_statement(yylineno, $2, $4, $6, $7); }
    ;

// SimpleStmt can be empty, so not explicitly making them optional should be fine

BreakStmt: tBREAK           { $$ = make_break_statement(yylineno); }
    ;

ContinueStmt: tCONTINUE     { $$ = make_continue_statement(yylineno); }
    ;





// EXPRESSIONS
// ============================

Expression: UnaryExpr                                    
          | Expression tOR Expression                    
            {$$ = make_binary_operation_expression(yylineno, opOr, $1, $3); }
          | Expression tAND Expression                   
            {$$ = make_binary_operation_expression(yylineno, opAnd, $1, $3); }
          | Expression rel_op Expression %prec REL_PREC  
            {$$ = make_binary_operation_expression(yylineno, $2, $1, $3); }
          | Expression add_op Expression %prec ADD_PREC  
            {$$ = make_binary_operation_expression(yylineno, $2, $1, $3); }
          | Expression mul_op Expression %prec MUL_PREC  
            {$$ = make_binary_operation_expression(yylineno, $2, $1, $3); }
          ;

UnaryExpr: PrimaryExpr                                  
         | unary_op UnaryExpr %prec UNARY_PREC 
            { $$ = make_unary_operation_expression(yylineno, $1, $2) ; }
         ;

rel_op: tEQUAL              { $$ = opEq ; }
      | tNE                 { $$ = opNeq ; }
      | '<'                 { $$ = opLt ; }
      | tLE                 { $$ = opLeq ; }
      | '>'                 { $$ = opGt ; }
      | tGE                 { $$ = opGeq ; }
      ;

add_op: '+'                 { $$ = opAdd ; }
    | '-'                   { $$ = opSub ; }
    | '|'                   { $$ = opBwOr ; }
    | '^'                   { $$ = opBwXor ; }
    ;

mul_op: '*'                 { $$ = opMul ; }
    | '/'                   { $$ = opDiv ; }
    | '%'                   { $$ = opMod ; }
    | tLSHIFT               { $$ = opLShift ; }
    | tRSHIFT               { $$ = opRShift ; }
    | '&'                   { $$ = opBwAnd ; }
    | tBWANDNOT             { $$ = opBwAndNot ; }
    ;

unary_op: '+'               { $$ = opPlus ; }
        | '-'               { $$ = opNeg ; }
        | '!'               { $$ = opBwCompl ; }
        | '^'               { $$ = opNot ; }
        ;

Operand: Literal
       | tIDENTIFIER        { $$ = make_identifier_expression(yylineno, $1); }
       | '(' Expression ')' { $$ = $2 ; }
       ;

Literal: tINTVAL            {$$ = make_literal_expression(yylineno, $1, kInt);}
       | tFLOATVAL          {$$ = make_literal_expression(yylineno, $1, kFloat);}
       | tRUNEVAL           {$$ = make_literal_expression(yylineno, $1, kRune);}
       | tSTRINGVAL         {$$ = make_literal_expression(yylineno, $1, kString);}
       ;

PrimaryExpr: Operand
           | PrimaryExpr Selector   { $$ = make_selector_expression(yylineno, $1, $2) ; }
           | PrimaryExpr Index      { $$ = make_index_expression(yylineno, $1, $2) ; }
           | AppendExpr             { $$ = $1 ; }
           | PrimaryExpr Arguments  { $$ = make_function_call_expression(yylineno, $1, $2) ; }
           ;

Selector: '.' tIDENTIFIER   { $$ = $2 ; }
        ;

Index: '[' Expression ']'   { $$ = $2 ; }
     ;

Arguments: '(' OptionalExpressionList ')' { $$ = $2 ; }
         ;

AppendExpr: tAPPEND '(' Expression ',' Expression ')' 
          { $$ = make_append_expression(yylineno, $3, $5); }
          ;


// Type casts are syntactically function calls


// EXPRESSION SUBGROUP
// ============================


OptionalExpressionList: %empty          { $$ = make_expression_vec(); }
                      | expression_list
                      ;

%%

