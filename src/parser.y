/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	char *text;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */



%token tBREAK;
%token tCASE;
%token tCHAN;
%token tCONST;
%token tCONTINUE;

%token tDEFAULT;
%token tDEFER;
%token tELSE;
%token tFALLTHROUGH;
%token tFOR

%token tFUNC;
%token tGO;
%token tGOTO;
%token tIF;
%token tIMPORT;

%token tINTERFACE;
%token tMAP;
%token tPACKAGE;
%token tRANGE;
%token tRETURN;

%token tSELECT;
%token tSTRUCT;
%token tSWITCH;
%token tTYPE;
%token tVAR;

%token tPRINT;
%token tPRINTLN;
%token tAPPEND;

// Double character operators

%token tLSHIFT;
%token tRSHIFT;
%token tBWANDNOT;

%token tPLUSASSIGN;
%token tMINUSASSIGN;
%token tTIMESASSIGN;
%token tDIVASSIGN;
%token tREMASSIGN;

%token tBWANDASSIGN;
%token tBWORASSIGN;
%token tBWXORASSIGN;
%token tLSHIFTASSIGN;
%token tRSHIFTASSIGN;
%token tBWANDNOTASSIGN;

%token tAND;
%token tOR;
%token tARROW;
%token tINC;
%token tDEC;

%token tEQUAL;

%token tNE;
%token tLE;
%token tGE;
%token tDEFINE;
%token tELLIPSIS;

%token '+'
%token '-'
%token '*'
%token '/'
%token '%'
%token '&'
%token '|'
%token '^'
%token '<'
%token '>'
%token '='
%token '!'
%token '('
%token ')'
%token '['
%token ']'
%token '{'
%token '}'
%token ','
%token '.'
%token ';'
%token ':'


%token <text> tINTVAL
%token <text> tFLOATVAL
%token <text> tSTRINGVAL
%token <text> tRUNEVAL

%token <text> tIDENTIFIER

%token UNARY

/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */

/*
%left tOR
%left tAND
%nonassoc tEQ tNE
%left '+' '-'
%left '*' '/'
%left UNARY
*/

/* Start token (by default if this is missing it takes the first production */
%start program

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
%%

// FILE STRUCTURE
// =============================

program : PackageClause ';' TopLevelDecls
    ;

// PRIMARY PROGRAM STRUCTURE
// =============================


PackageClause : tPACKAGE tIDENTIFIER
    ;

TopLevelDecls : 
    | TopLevelDecl ';' TopLevelDecls
    ;


// DECLARATION STRUCTURE
// ============================

Declaration : TypeDecl
    | VarDecl
    ;

TopLevelDecl : Declaration 
    | FunctionDecl
    ;




// VARIABLE DECLARATION
// ===========================

// TODO WEED: check that the numbers on each side are the same

VarDecl : tVAR IdentifierList Type
    | tVAR '(' VarSpecs ')'
    ;

VarSpecs :
    | VarSpec ';' VarSpecs
    ;

VarSpec : IdentifierList Type
    | IdentifierList Type '=' ExpressionList
    | IdentifierList '=' ExpressionList
    ;

IdentifierList : tIDENTIFIER
    | IdentifierList ',' tIDENTIFIER
    ;

ExpressionList : Expression
    | Expression ',' ExpressionList
    ;


// TYPE DECLARATIONS
// ============================
TypeDecl : tTYPE TypeSpec
    | tTYPE '(' TypeSpecs ')'
    ;

TypeSpecs : /*empty*/
    | TypeSpec ';' TypeSpecs
    ;

TypeSpec : AliasDecl
    | TypeDef
    ;

// We probably don't need this
AliasDecl : tIDENTIFIER '=' Type
    ;

TypeDef : tIDENTIFIER Type
    ;



// FUNCTION DECLARATION
// ============================

FunctionDecl : tFUNC tIDENTIFIER FuncSignature Block
    ;

FuncSignature: FuncParameters FuncResult
    ;

FuncParameters: '('  FuncParameterList  ')'
    ;

FuncResult:
    | Type

FuncParameterList: FuncParameterDecl
    | FuncParameterDecl ',' FuncParameterDecl
    ;

FuncParameterDecl: IdentifierList Type
    ;



// TYPES
// ============================

Type : TypeName
    | TypeLit
    | '(' Type ')'
    ;

// Basic types are just identifiers
TypeName : tIDENTIFIER
    ;

TypeLit : ArrayType
    | StructType
    | SliceType
    ;


// SLICES

SliceType : '[' ']' Type
    ;


// ARRAYS

ArrayType : '[' tINTVAL ']' Type
    ;


// STRUCTS

StructType : tSTRUCT '{'  FieldDecls '}'
    ;

FieldDecls : /*empty*/
           | FieldDecl ';' FieldDecls

FieldDecl : IdentifierList Type
    ;



// STATEMENT STRUCTURE
// ============================

// Need to double check if we support fallthrough 
Statement : Declaration
    | SimpleStmt
    | ReturnStmt
    | BreakStmt
    | ContinueStmt
    | Block
    | IfStmt
    | SwitchStmt
    | ForStmt
    | PrintStmt
    | PrintlnStmt
    ;

SimpleStmt : EmptyStmt
    | ExpressionStmt
    | IncDecStmt
    | Assignment
    | ShortVarDecl
    ;


// STATEMENTS
// ============================


EmptyStmt:
    ;

Block : '{' StatementList '}'
    ;

StatementList: /* empty */
             | StatementList Statement ';'
             ;

// TODO WEED: not all expressions are valid; need to weed
ExpressionStmt : Expression
    ;


// TODO WEED: make sure number is same on both sides
// TODO: perhaps split this into to seperate rules, one for "=" and one for the rest
Assignment: ExpressionList assign_op ExpressionList
    ;

assign_op : '='
          | add_assign_op
          | mul_assign_op
          ;

add_assign_op : tPLUSASSIGN | tMINUSASSIGN | tBWORASSIGN | tBWXORASSIGN
mul_assign_op : tTIMESASSIGN | tDIVASSIGN | tREMASSIGN | tLSHIFTASSIGN
              | tRSHIFTASSIGN | tBWANDASSIGN |tBWANDNOTASSIGN
              ;


// declaration statements are just Declarations; they were done earlier

// TODO WEED: same number on both sides. Also check for the correct use of _
ShortVarDecl : tVAR IdentifierList tDEFINE ExpressionList
    ;

IncDecStmt: Expression tINC
    | Expression tDEC
    ;

PrintStmt: tPRINT '(' OptionalExpressionList ')'
    ;

PrintlnStmt: tPRINTLN '(' OptionalExpressionList ')'
    ;

ReturnStmt: tRETURN 
          | tRETURN Expression
          ;


IfStmt: tIF OptionalSimpleStmt Expression Block ElseStmt
    ;

OptionalSimpleStmt: /* empty */
                    | SimpleStmt ';'
                    ;


ElseStmt: /* empty */
        | tElse IfStmt
        | tElse Block
        ;


SwitchStmt: tSWITCH OptionalSimpleStmt Expression '{' CaseClauses '}'
          | tSWITCH OptionalSimpleStmt '{' CaseClause '}'
    ;

CaseClauses: /* empty */
           | CaseClauses CaseClause
           ;

// TODO: decide if maybe to fuse to next two rules for easier AST building
CaseClause: SwitchCase ':' StatementList
    ;

SwitchCase: tCASE ExpressionList
    | tDEFAULT
    ;


ForStmt: tFOR Block
    | tFOR Expression Block
    | tFOR ForClause Block
    ;

// TODO WEED: make sure the last SimpleStmt is not a short variable declaration
// SimpleStmt can be empty, so not explicitly making them optional should be fine
ForClause: SimpleStmt ';' Expression ';' SimpleStmt
    ;

BreakStmt: tBREAK
    ;

ContinueStmt: tCONTINUE
    ;





// EXPRESSIONS
// ============================

Expression: UnaryExpr
          | Expression binary_op Expression

UnaryExpr: PrimaryExpr
         | unary_op UnaryExpr


binary_op: tOR
         | tAND
         | rel_op
         | add_op
         | mul_op

rel_op: tEQUAL
      | tNE
      | '<'
      | tLE
      | '>'
      | tGE

add_op: '+'
    | '-'
    | '|'
    | '^'
    ;

mul_op: '*'
    | '/'
    | '%'
    | tLSHIFT
    | tRSHIFT
    | '&'
    | tBWANDNOT
    ;

unary_op: '+'
        | '-'
        | '!'
        | '^'
        ;

Operand: Literal
       | Identifier
       | '(' Expression ')'
       ;

Literal: tINTVAL
       | tFLOATVAL
       | tRUNEVAL
       | tSTRINGVAL
       ;

PrimaryExpr: Operand
           | Conversion
           | PrimaryExpr Selector
           | PrimaryExpr Index
           | PrimaryExpr Arguments
           ;

// TODO WEED: must not be blank
Selector: '.' identifier
        ;
Index: '[' Expression ']'
     ;

Arguments: '(' OptionalExpressionList ')
         ;


AppendExpr: tAPPEND '(' expr ',' expr ')'
          ;






// EXPRESSION SUBGROUP
// ============================

ExpressionList: Expression
    | ExpressionList ',' Expression
    ;

OptionalExpressionList:  /* empty */
                      | ExpressionList
                      ;

%%

